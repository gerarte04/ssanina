### Problem up12-5: up12-5

Программа должна создать три нити, пронумерованные от 0 до 2. Нити работают над общим глобальным массивом типа ```double``` из трех элементов. Каждая нить 1000000 раз выполняет следующие операции:

* Нить 0 прибавляет к элементу ```[0]``` число 100 и вычитает из элемента ```[1]``` число 101.
* Нить 1 прибавляет к элементу ```[1]``` число 200 и вычитает из элемента ```[2]``` число 201.
* Нить 2 прибавляет к элементу ```[2]``` число 300 и вычитает из элемента ```[0]``` число 301.

Программа дожидается завершения всех нитей и выводит на стандартный поток вывода значения элементов массива. Для вывода используйте форматное преобразование ```%.10g```.

Для обеспечения корректной работы используйте один мьютекс. Сравните результат работы с результатом работы без использования мьютексов.

Используйте одну функцию нити для всех трех нитей. В программе объявите константу со значением 3 и константу со значением 1000000 и используйте их.

### Problem up12-6: up12-6

На стандартном потоке ввода задаются:

* Число счетов ```acc_count``` - положительное целое 32-битное число.
* Число нитей ```thr_count``` - положительное целое 32-битное число.
* Далее для каждой нити задаются 5 чисел, описывающих параметры работы нити:
    * Число итераций - положительное целое 32-битное число.
    * Индекс первого счета (в интервале ```[0; acc_count)```).
    * Сумма для зачисления на первый счет или списания с первого счета (```double```).
    * Индекс второго счета (в интервале ```[0; acc_count)```, не совпадает с первым индексом).
    * Сумма для зачисления на второй счет или списания со второго счета (```double```).

Счета хранятся в типе ```double```. Начальное состояние каждого счета - нулевое.

Главная программа должна создать ```thr_count``` нитей, каждая из которых должна обновлять состояние двух счетов следующим образом.

Каждая нить выполняет предписанное ей число итераций обновления состояния счетов. На каждой итерации к первому счету прибавляется сумма для зачисления на первый счет, а ко второму счету - сумма для зачисления на второй счет. Отрицательная сумма подразумевает списание со счета.

После завершения работы нитей главная программа выводит на стандартный поток вывода итоговое состояние всех счетов с помощью форматного преобразования ```%.10g``` и завершает работу.

Каждая нить должна блокировать только те счета, с которыми ведется работа. Обновление и первого, и второго счета должно выполняться в одной критической секции в каждой итерации цикла.

Не используйте глобальные переменные.

**Examples**

_Input_

```
2
2
1000000 0 2 1 -1
1000000 0 -1 1 3
```

_Output_

```
1000000
2000000
```

### Problem up12-7: up12-7

На стандартном потоке ввода задаются беззнаковые 64-битные целые числа ```low``` и ```high``` и 32-битное положительное целое число ```count```.

Главная программа создает нить, которая проверяет на простоту числа последовательно с шагом 1, начиная с ```low``` и до ```high``` включительно. Когда нить обнаруживает очередное простое число, оно сообщается главной нити.

Главная нить ждет от созданной нити ```count``` простых чисел. При получении очередного числа оно выводится на стандартный поток вывода.

Передача значений из нити в основную программу выполняется с помощью ```count``` пар promise/future. Если на отрезке ```[low; high]``` нет count простых чисел, при достижении значения high рабочая нить сообщает об этом передачей исключения типа ```uint64_t``` со значением ```high```. Главная программа ловит исключение и печатает переданное значение.

Для проверки на простоту используйте функцию, реализованную ранее для аналогичных задач.

Вывод программы детерминирован, так как простые числа передаются из рабочей нити в основную без потерь.

**Examples**

_Input_

```
1000 2000 5
```

_Output_

```
1009
1013
1019
1021
1031
```

_Input_

```
1000 1010 5
```

_Output_

```
1009
1010
```

### Problem up12-8: up12-8

Напишите программу, вычисляющую число Пи методом Монте-Карло.

Рассмотрим произвольный квадрат с центром в начале координат и вписанный в него круг. Будем случайным образом выбирать точки в этом квадрате и считать, какая доля точек попала в круг. Отношение числа попаданий к числу попыток будет равно отношению площадей, то есть pi/4. Чем больше взятых наугад точек мы проверим, тем точнее будет отношение площадей.

Программе в первом аргументе командной строки передается число потоков. Во втором аргументе командной строки передается число итераций алгоритма, которое должен выполнить каждый поток.

Результат выведите на стандартный поток вывода не менее чем с 5 десятичными знаками после точки.

Для генерации случайных чисел используйте функцию ```rand_r```. В качестве seed передавайте ей номер текущего потока.

Для создания потоков используйте ```std::async```. Каждый поток должен возвращать два значения: количество точек, попавших внутрь круга, и общее количество точек. Потоки должны выполняться параллельно.

**Examples**

_Input_

```
```

_Output_

```
3.141592653589793238462643383279502884197169399375105820974944592307816406286
```

### Problem up12-9: up12-9

Разработайте шаблонную функцию ```async_launch```, запускающую заданную функцию с произвольными аргументами в отдельной нити, и запускающую заданную callback-функцию после того, как первая функция закончит вычисления. В отличие от ```std::async``` функция ```async_launch``` не возвращает объект future, с помощью которого можно ждать завершения запущенной функции.

Рассмотрим пример:

```c++
int func(int a, int b)
{
    std::this_thread::sleep_for(std::chrono::seconds(1));
    return a + b;
}
```

Эта функция через одну секунду после запуска возвращает сумму своих аргументов.

```c++
void print(int v)
{
    std::cout << v << std::endl;
}
```

Функцию ```async_launch``` можно использовать следующим образом:

```c++
async_launch(std::function(func), std::function(print), 2, 6);
```

Функция ```async_launch``` завершает выполнение немедленно, запустив отдельную нить, в которой вычисляется ```func(2, 6)```. Когда вычисление функции ```func``` завершится, в том же потоке, в котором вычислялась функция ```func``` будет вызвана функция ```print```, которой будет передан результат вычисления функции: ```8```. После этого запущенная нить завершится.

В качестве первых двух аргументов функция ```async_launch``` должна принимать функции, лямбды, классы-функторы и т. п. У первой должно поддерживаться произвольное число параметров. Вторая функция должна принимать параметр типа-результата первой функции и ничего не возвращать.
