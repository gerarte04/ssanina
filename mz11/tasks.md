### Problem mz11-1: mz11-1

Напишите функцию ```process``` которая принимает вектор беззнаковых 64-битных целых чисел (```uint64_t```) ```v``` для модификации и беззнаковое 32-битное целое значение ```s``` (```s > 0```).

Функция ```process``` должна модифицировать вектор ```v``` таким образом, что через каждые ```s``` элеметов должен быть вставлен новый элемент, содержащий сумму всех элементов исходного вектора от начала и до последнего элемента перед вставляемым значением. Если последняя группа неполная, элемент в конец не добавляется.

Например, для вектора ```v = {2, 3, 4, 5, 6}``` и значения ```s = 2``` после исполнения функции вектор ```v``` должен быть равен ```{2, 3, 5, 4, 5, 14, 6}```.

Функция должна быть максимально эффективной.

### Problem mz11-2: mz11-2

В пространстве имен ```Sample``` напишите шаблонный класс ```Matrix```, который предназначен для работы с двухмерными матрицами константного размера. Шаблонный класс должен параметризоваться типом ```T``` элементов матрицы, количеством строк (типа ```size_t```) и количеством столбцов (типа ```size_t```), например:

```c++
Sample::Matrix<int, 2, 3>
```

Класс не должен использовать динамическое выделение памяти и хранить только элементы матрицы без каких-либо накладных расходов.

Класс должен поддерживать операцию индексации для доступа к элементам, которая может находиться как слева от операции присваивания, так и справа. Например,

```c++
Sample::Matrix<int, 2, 2> m;

m[0][1] = m[1][0];
```

Использовать стандартные контейнерные классы запрещено.

### Problem mz11-3: mz11-3

Напишите функцию:

```c++
void calc_binom(int m, int k, std::function<void(uint64_t)> cb);
```

Функция должна вычислить биноминальный коэффициент $C^k_m$ и вызвать указанный в аргументе callable с вычисленным значением.

Для вычислений запрещено использовать циклы. Запрещено использовать ```return```. Запрещено использовать какие-либо функции стандартной библиотеки. Запрещено передавать параметры по ссылке или указателю. Запрещено вызывать любые другие функции, кроме ```calc_binom```.

Например,

```c++
calc_binom(3, 2, [](uint64_t z) { std::cout << z << std::endl; });
```

должно вывести

```
3
```

### Problem mz11-4: mz11-4

Опишите абстрактный класс ```Figure```, который будет корнем полиморфной иерархии классов, описывающих двухмерные фигуры.

Класс должен определять метод ```equals``` для перекрытия в производных классах. Метод будет принимать указатель на фигуру и возвращать ```true```, если фигуры равны.

Напишите классы ```Rectangle``` с конструктором от двух целых (```int```) аргументов и ```Triangle``` с конструктором от трех целых (```int```) аргументов. Для этих классов определите методы ```equals```. Равенство фигур понимается как равенство соответствующих сторон, то есть прямоугольник (10, 5) не равен прямоугольнику (5, 10).

Иерархия должна быть расширяемой, то есть добавление нового класса-наследника ```Figure``` должно не ломать существующий код и не требовать его модификации.

Например,

```c++
Rectangle r1(10, 5), r2(10, 2), r3(10, 5), r4(5, 10);
Triangle t1(1, 2, 3);
Figure *f = &r1;

assert(!f->equals(&r2));
assert(f->equals(&r3));
assert(!f->equals(&r4));
assert(!f->equals(&t1));
assert(!f->equals(nullptr));
```

### Problem mz11-5: mz11-5

Дана грамматика:

```
S → aA | bB
A → aS | b | cB | cC
B → aS
C → a | bB
```

Напишите программу, которая будет считывать символы со стандартного потока ввода, игнорируя все пробельные символы. Если считанная цепочка символов принадлежит языку, программа должна вывести на стандартный поток вывода строку 1, в противном случае на стандартный поток вывода должно быть выведено 0.

Программа должна содержать реализацию ДКА.

### Problem mz11-6: mz11-6

Дана грамматика:

```
S → aAb | cB
A → cAd | e
B → bB | d | ε
```

Напишите программу, которая будет считывать символы со стандартного потока ввода, игнорируя все пробельные символы. Если считанная цепочка символов принадлежит языку, программа должна вывести на стандартный поток вывода строку 1, в противном случае на стандартный поток вывода должно быть выведено 0.

Программа должна содержать реализацию рекурсивного спуска.

### Problem mz11-7: mz11-7

Напишите функцию:

```c++
std::string gen_power(uint32_t power);
```

Которая сгенерирует польскую запись выражения, содержащего переменную ```x```, константу 1, операцию умножения ```*``` и операцию копирования (дублирования) значения на верхушке стека ```!``` (восклицательный знак). Результатом вычисления польской записи должна быть степень ```power``` переменной ```x```.

Строка-результат не должна содержать пробельных символов.

Например, если ```power == 2```, то результат работы функции может быть равен:

```
xx*
```
