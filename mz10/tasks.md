### Problem mz10-1: mz10-1

На вход подается описание грамматики в следующем виде: каждое правило состоит из двух символьных строк, разделяемых произвольным количеством пробельных символов. Грамматика представляет собой последовательность правил. Таким образом, на вход подается четное число строк, разделяемых произвольным количеством пробельных символов.

В строках допускаются:

* Заглавные латинские буквы, обозначающие нетерминалы.
* Строчные латинские буквы и цифры, обозначающие терминалы.
* Символ подчеркивания, обозначающий пустую правую часть (эпсилон).

Символ подчеркивания может находится только в правой части правила, в этом случае он является единственным символом в правой части.

Начальный нетерминал грамматики всегда ```S```.

Гарантируется, что входная грамматика — контекстно-свободная (в том числе укорачивающая), то есть удовлетворяет правилам, описанным в задаче 'is-context-free'.

На стандартный поток вывода напечатайте:

* ```2``` если грамматика является контекстно-свободной, но не неукорачивающей контекстно-свободной и не регулярной.
* ```21``` если грамматика является неукорачивающей контестно-свободной, но не является регулярной.
* ```31``` если грамматика является леволинейной регулярной грамматикой, но не является левоавтоматной
* ```311``` если грамматика является левоавтоматной грамматикой
* ```32``` если грамматика является праволинейной регулярной грамматикой, но не является правоавтоматной
* ```321``` если грамматика являеся правоавтоматной грамматикой

В случае неоднозначности выводите меньший номер.

В леволинейной или праволинейной грамматике в правой части правил допускается произвольное (в том числе нулевое) количество терминальных символов. В лево- или право-автоматной грамматике в правой части правил всегда должен присутствовать ровно один терминал. Но в автоматной грамматике в качестве исключения допускаются два правила для вывода пустой цепочки из ```S``` вида:

```
S _
S A
```

В этом случае грамматика со стартовым нетерминалом ```A``` должна быть автоматной в строгом смысле, а нетерминал ```S``` не должен использоваться в правых частях правил.

**Examples**

_Input_

```
S abS
S ceA
A zA
A b
```

_Output_

```
32
```

### Problem mz10-2: mz10-2

На вход подается описание КС-грамматики в следующем формате:

```
<левая часть> <правая часть>
```

где ```<...>``` – строки, состоящие из цифр, строчных и заглавных латинских символов, а также символа ```_```, означающего пустую цепочку (эпсилон).

Строчные символы и цифры – терминальные (из $Т$). \
Заглавные – нетерминальные (из $N$). \
Правила грамматики задаются не в сокращенной форме.

На выходе программа должна вывести: \
правила эквивалентной грамматики без недостижимых символов не в сокращенной форме.

**Пример**

_Вход_

```
S a
S Bc
D e
```

_Выход_

```
S a
S Bc 
```

### Problem mz10-3: mz10-3

Напишите программу, моделирующую работу детерминированного конечного автомата (ДКА). Описание автомата и входная строка вводятся на стандартном потоке ввода. Результат работы автомата над данной строкой выводится на стандартный поток вывода.

Описание автомата задаётся в следующей форме. Сначала задаётся функция перехода автомата. Функция перехода задаётся в виде троек

```
CUR CHAR NEW
```

где ```CUR``` — идентификатор исходного состояния — произвольная символьная строка, не содержащая пробельные символы. ```CHAR``` — символьная строка длиной ровно 1 символ. ```NEW``` — идентификатор целевого состояния — произвольная символьная строка, не содержащая пробельные символы. Элементы описания перехода могут отделятся друг от друга произвольным количеством пробельных символов. Описание функции перехода завершается строкой ```END``` в качестве идентификатора исходного состояния. Элементы ```CHAR``` и ```NEW``` отсутствуют.

Далее перечисляются заключительные состояния автомата. Каждое состояние — это символьная строка. Список состояний завершается символьной строкой ```END```.

Далее задаётся начальное состояние автомата — символьная строка. Затем задаётся проверяемое слово — символьная строка. Все элементы входного файла могут отделяться друг от друга произвольным количеством пробельных символов.

Можете предполагать, что входные данные корректны, то есть удовлетворяют спецификации и действительно задают детерминированный конечный автомат.

Результат работы автомата должен быть напечатан в следующем виде. Сначала напечатайте число 1, если данный автомат допускает данную цепочку, и 0 в противном случае. Затем напечатайте количество символов, прочитанных во входной цепочке к моменту принятия автоматом решения (текущий символ не считается прочитанным). Наконец, напечатайте идентификатор состояния, в котором в данный момент находился автомат.

**Examples**

_Input_

```
A a A
A b B
B a C
B b B
C a C
END
B C END
A
aaabbbbba
```

_Output_

```
1
9
C
```

_Input_

```
A a A
A b B
B a C
B b B
C a C
END
B C END
A
abab
```

_Output_

```
0
3
C
```

### Problem mz10-4: mz10-4

Дано корректное математическое выражение, состоящее из переменных, обозначаемых строчными латинскими буквами (только одна буква), инфиксных бинарных операций и круглых скобок для группировки подвыражений.

Все операции имеют ассоциативность слева направо и приоритеты, указанные в таблице: 

| Приоритет      | Операции         |
|----------------|------------------|
| 1 (наибольший) | ```*```, ```/``` |
| 2              | ```+```, ```-``` |
| 3              | ```&```          |
| 4              | ```^```          |
| 5 (наименьший) | ```\|```         |

Требуется удалить из выражения все лишние пары скобок, не влияющие на порядок операций в нём (операции трактовать абстрактно, без какого-либо математического смысла, опираясь только на формальный порядок операций).

Приоритет определяет, в каком порядке выполняются операции в цепочке, а ассоциативность определяет направление вычислений в цепочке операций одного приоритета.

**Examples**

| вход    | выход |
|---------|-------|
| ```a+(b*c)``` | ```a+b*c``` |

(у ```*``` приоритет выше, чем у ```+```, поэтому она и так выполняется первой, скобки лишние);

| вход    | выход |
|---------|-------|
| ```((a+b)+(c+d))``` | ```a+b+(c+d)``` |

(Скобки вокруг всего выражения допустимы, но никогда не влияют на порядок вычисления внутри. Поскольку ассоциативность всех операций слева направо, первые внутренние скобки лишние, а вторые – нет, без них выражение было бы эквивалентно ```(((a+b)+c)+d)```);

| вход    | выход |
|---------|-------|
| ```((a)+b)&c^d``` | ```a+b&c^d``` |

(скобки вокруг переменной всегда лишние).

| вход    | выход |
|---------|-------|
| ```(((a)&b^c\|((d))))``` | ```a&b^c\|d``` |
| ```a``` | ```a``` |

**Указание**: используйте рекурсивный спуск.

**Input format**

Одна строка, содержащая исходное математическое выражение не длиннее 100 символов.

Строка всегда завершается символом перевода строки.

**Output format**

Одна строка с математическим выражением без лишних скобок.

Строка всегда завершается символом перевода строки.

### Problem mz10-5: mz10-5

На стандартный поток ввода программе подаётся выражение в польской записи. Выражение может содержать имена переменных и бинарные операции ```+```, ```-```, ```*```, ```/```. Имя переменной — это строчная латинская буква. Элементы ввода могут разделяться произвольным количеством пробельных символов.

Напечатайте введённое выражение в инфиксной записи. Для сохранения приоритетов бинарные операции заключите в скобки. Выражение напечатайте в одной строке текста без пробельных символов.

**Examples**

_Input_

```
abc++
```

_Output_

```
(a+(b+c))
```
