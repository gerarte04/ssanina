### Problem mz08-1: mz08-1

На стандартном потоке ввода подается последовательность строк, состоящих из непробельных символов и разделенных пробельными символами. Напечатайте эту последовательность в обратном порядке по одной строке на одной строке выходного текстового файла.

Не используйте ни массивов, ни других контейнерных классов (вектор). Допускается без изменений хранить входную строку в ```std::string```. Выход из рекурсии должен выполняться с помощью исключения. **Выход из рекурсивной функции с помощью явного или неявного return запрещен.** Печать строки должна выполняться в деструкторе некоторого класса при обработке исключения (свертке стека). 

### Problem mz08-2: mz08-2

Некоторая рекурсивная функция ```func``` от трех целых аргументов ```a```, ```b```, ```k``` (```a, b >= 1```, ```k >= 0```) определена следующим образом:

* ```func(a, b, k) == a + b``` при ```k == 0```
* ```func(a, b, k) == a``` при ```k > 0, b == 1```
* ```func(a, b, k) == f(a, f(a, b - 1, k), k - 1)``` при ```k > 0, b > 1```

На стандартном потоке ввода подаются тройки чисел: два 64-битных знаковых целых положительных числа ```a```, ```b``` и 32-битное целое неотрицательное число ```k```. Для каждой тройки чисел на стандартный поток вывода напечатайте значение описанной выше функции.

Параметры на входе будут таковы, что вычисление завершится за разумное время. Для вычислений достаточно 64-битного целого знакового типа.

Для возврата значения из рекурсии используйте исключения. **Выход из рекурсивной функции с помощью явного или неявного return запрещен.**

Напишите свой класс (например, ```Result```) для передачи результата вычислений вместе с исключением. Не используйте выбрасывание исключений базовых (например, ```int```) типов.

В комментарии в начале программы опишите, что из себя представляет эта рекурсивная функция.

### Problem mz08-3: mz08-3

Реализуйте класс ```S``` следующим образом:

* Класс хранит целое число (типа ```int```).
* Число считывается со стандартного потока ввода в конструкторе.
* Число выводится на стандартный поток вывода в деструкторе.
* Следующая программа:

  ```c++
  using namespace std;
  void func(S v)
  {
      if (v) {
          func(move(v));
      }
  }
  
  int main()
  {
      func(S());
  }
  ```

  считывает последовательность целых чисел и выводит на стандартный поток вывода их сумму.
* Если входная последовательность пустая, программа не выводит ничего.

Проверка на переполнение не требуется.

Глобальные переменные, ```static```, ```mutable``` запрещены.

Сдаваемый на проверку класс должен подключать необходимые заголовочные файлы.

**Examples**

_Input_
```
1 2 3
```
_Output_
```
6
```
### Problem mz08-4: mz08-4

В пространстве имен ```Equations``` определите шаблонную функцию ```quadratic```, решающую уравнение $az^2+bz+c=0$ в поле комплексных чисел над любым вещественным типом, поддерживаемым в заголовочном файле ```<complex>```. Функция принимает массив (```std::array```) ```v``` из трех элементов комплексных коэффициентов уравнения ($c$ – ```v[0]```, $b$ – ```v[1]```, $a$ – ```v[2]```), функция возвращает пару ```std::pair``` из булевского значения и вектора корней. Булевское значение (```first```) равно ```false```, если корней уравнения бесконечно много. В противном случае ```first``` равно ```true``` и в векторе ```second``` возвращается вектор корней, содержащий 0 элементов, если корней нет; 1 элемент, если уравнение имеет один корень (то есть линейное); 2 элемента, если уравнение имеет два корня (возможно, равные).

Если на вход передается массив (```std::array```) другого размера или массив не комплексных чисел - поведение функции не определено.

Предусмотрите ```EPS``` для сравнения ```std::norm()``` с нулем равным ```32 * epsilon()``` (см. ```std::numeric_limits```).

Пример использования функции:

```c++
int main()
{
    using namespace std::complex_literals;

    std::array v1{ 1.0 + 2.0i, 2.0 + 0i, 3 + 1.3i };

    auto [res, v2] = Equations::quadratic(v1);
    std::cout << res;
}
```

Или для стандарта C++11:

```c++
int main()
{
    std::array<std::complex<double>, 3> v1{
        std::complex<double>(1.0, 2.0),
        std::complex<double>(2.0, 0),
        std::complex<double>(3, 1.3)
    };

    auto res = Equations::quadratic(v1);
    std::cout << res.first;
}
```

### Problem mz08-5: mz08-5

По примеру входных данных и результату работы определите, какие вычисления производит программа.

В решении используйте только средства и библиотеки Си++ (```std::chrono```). Библиотеками языка Си и POSIX пользоваться запрещено.

**Examples**

_Input_

```
1985-10-26
1955-11-05
1955-11-12
1985-10-26
2015-10-21
```

_Output_

```
32848
```

_Input_

```
1990-01-01
1991-01-01
1990-01-01
```

_Output_

```
730
```
